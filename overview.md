## 構成概要

ローカルではリバースプロキシにnginx、アプリケーションサーバにGoを用いて開発を行いました。

ただ、お金がかかってしまうのでホスティングするときはnginxを抜いてGoのみCloud Runにデプロイを行いました。

## コードの概要

初めての試みですが、クリーンアーキテクチャを用いて実装を行いました。

このコードはinfra層 interface層 usecase層 repository層に分けられています。

### infra層

ここではGoのライブラリのGinを用いてルーティングやサーバーの初期設定を行っています。

このとき、下層のContoller層を呼び出す必要があるのですが、ルーターの初期化関数に引数を連ねるのはきれいではないと個人的に思ったのでControllerのDAO(DTO?)的なものを実装してそれを受け渡すことできれいなrouterの初期化を図りました。

### interface層(controller)

ここでは値の処理を行うusecase層の橋渡しを行っています。

クエリパラメータが存在しなかったり、不要なクエリパラメータが送られてきたらここで弾く処理を実装しています。

要は値の処理に関係無い問題をここで取り除く処理を行っています。

(フィボナッチ数の番号がマイナス等はこれはフィボナッチ数の処理の問題だけれど、そもそも番号が与えられない等はそれ以前の問題)

## usecase層
ここでは前述の通り値の処理を行っています。すなわちフィボナッチ数を求める処理を行っています。

色々調べた結果動的計画法が一番早いのでこの手法を使ってフィボナッチ数の計算を行っています。

動的計画法ではn番目のフィボナッチ数を計算した際に、スライスのn番目に値の書き込み、それをn+1(n+2)の計算の際に最適的に呼び出すことで計算量を少なくする方法です。

ここで行った工夫としては、スライスのバリューに `math/big`を用いたことです。

最初にintを用いた際にn=99のときにオーバーフローしてしまったのでint64に修正したのですが、それでも同様の結果になってしまったので最終的にGoで一番大きい値を扱えるライブラリを用いて計算結果を記録しました。

## repository層
DBを操作すること等があればここにビジネスロジック(スキーマとか)を書くのですが、今回はリクエストに関連付けるデータも無いようなので特に使っておりません。


お時間いただきありがとうございます。
稚拙なコードですがレビューいただけると幸いです。
